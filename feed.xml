<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://cppalliance.org/feed.xml" rel="self" type="application/atom+xml" /><link href="http://cppalliance.org/" rel="alternate" type="text/html" /><updated>2019-04-05T23:29:32+00:00</updated><id>http://cppalliance.org/feed.xml</id><title type="html">The C++ Alliance</title><subtitle>The C++ Alliance is dedicated to helping the C++ programming language evolve. We see it developing as an ecosystem of open source libraries and as a growing community of those who contribute to those libraries..</subtitle><entry><title type="html">Damian’s March Update</title><link href="http://cppalliance.org/company,/damian/2019/04/04/DamiansAprilUpdate.html" rel="alternate" type="text/html" title="Damian's March Update" /><published>2019-04-04T00:00:00+00:00</published><updated>2019-04-04T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/04/04/DamiansAprilUpdate</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/04/04/DamiansAprilUpdate.html">&lt;p&gt;This month I’ve been working on the following projects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Certify&lt;/li&gt;
  &lt;li&gt;Boost.Beast&lt;/li&gt;
  &lt;li&gt;Boost.Build&lt;/li&gt;
  &lt;li&gt;BeastLounge&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;certify&quot;&gt;Certify&lt;/h1&gt;
&lt;p&gt;Certify now properly verifies the hostname of a TLS server according to RFC 2818
or TLS-DANE if available. Additionally, initial support for CRLSets has been
merged, although it’s still missing integration into the verification code.&lt;/p&gt;

&lt;p&gt;I’ve also invested a fair bit of time into researching what other open source
libraries do to perform certificate status checking. I’ve looked into BoringSSL,
mbedTLS, Botan and even the Go standard library. It’s interesting that no
library has a default way of performing the status check of a certificate and
it’s left up to the user.&lt;/p&gt;

&lt;p&gt;The Windows implementation of the certificate store in Certify will now properly
use the entire chain passed by the peer, which resolves certificate failures in
less common cases.&lt;/p&gt;

&lt;p&gt;Don’t forget to star the repository: https://github.com/djarek/certify!&lt;/p&gt;

&lt;h1 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h1&gt;
&lt;p&gt;Most of the work this month involved making Beast compile faster and use less
memory by expanding the code that can use split compilation and reducing redundant
dependencies in a few places.&lt;/p&gt;

&lt;h1 id=&quot;boostbuild&quot;&gt;Boost.Build&lt;/h1&gt;
&lt;p&gt;I’ve worked on implementing 2 improvements that make it less painful to work with b2:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;support for finding OpenSSL&lt;/li&gt;
  &lt;li&gt;support for sanitizers in gcc and clang
Both are currently still in review.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;beastlounge&quot;&gt;BeastLounge&lt;/h1&gt;
&lt;p&gt;The project lacked functioning CI so I implemented one. Since the project was
previously only compiled on MSVC, this proved to be quite challenging, because
MSVC accepts code that is not valid C++11. I’ve also created a deplyoment docker
image, which allows running the application in popular cloud environments, like
Heroku. A development version of the app is available at https://beast-lounge.herokuapp.com/.&lt;/p&gt;</content><author><name></name></author><summary type="html">This month I’ve been working on the following projects: Certify Boost.Beast Boost.Build BeastLounge Certify Certify now properly verifies the hostname of a TLS server according to RFC 2818 or TLS-DANE if available. Additionally, initial support for CRLSets has been merged, although it’s still missing integration into the verification code. I’ve also invested a fair bit of time into researching what other open source libraries do to perform certificate status checking. I’ve looked into BoringSSL, mbedTLS, Botan and even the Go standard library. It’s interesting that no library has a default way of performing the status check of a certificate and it’s left up to the user. The Windows implementation of the certificate store in Certify will now properly use the entire chain passed by the peer, which resolves certificate failures in less common cases. Don’t forget to star the repository: https://github.com/djarek/certify! Boost.Beast Most of the work this month involved making Beast compile faster and use less memory by expanding the code that can use split compilation and reducing redundant dependencies in a few places. Boost.Build I’ve worked on implementing 2 improvements that make it less painful to work with b2: support for finding OpenSSL support for sanitizers in gcc and clang Both are currently still in review. BeastLounge The project lacked functioning CI so I implemented one. Since the project was previously only compiled on MSVC, this proved to be quite challenging, because MSVC accepts code that is not valid C++11. I’ve also created a deplyoment docker image, which allows running the application in popular cloud environments, like Heroku. A development version of the app is available at https://beast-lounge.herokuapp.com/.</summary></entry><entry><title type="html">Marshall’s March Update</title><link href="http://cppalliance.org/marshall/2019/04/02/MarshallsAprilUpdate.html" rel="alternate" type="text/html" title="Marshall's March Update" /><published>2019-04-02T00:00:00+00:00</published><updated>2019-04-02T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/04/02/MarshallsAprilUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/04/02/MarshallsAprilUpdate.html">&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This month, I spent far more time reviewing other people’s code and preparing talks for conferences than the previous few months. The Boost release process consumed a fair chunk of time as well.&lt;/p&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The big news is: we released LLVM 8 this month! (March 20th). You can get the sources and pre-built binaries from the &lt;a href=&quot;http://releases.llvm.org/download.html#8.0.0&quot;&gt;LLVM download page&lt;/a&gt;, or wait for your system vendor to provide you with an update.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;h3 id=&quot;lwg-papers-implemented-this-month&quot;&gt;LWG papers implemented this month.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P0811&quot;&gt;P0811&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::midpoint&lt;/code&gt; for integral and pointer types. This turned out to be &lt;em&gt;quite&lt;/em&gt; involved, and spawned a &lt;a href=&quot;https://bugs.llvm.org/show_bug.cgi?id=40965&quot;&gt;clang bug report&lt;/a&gt;. On the plus side, now I have a topic for a talk for CppCon this fall.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Still to do, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::midpoint&lt;/code&gt; for floating point types. This is done, but it needs better tests.&lt;/p&gt;

&lt;h3 id=&quot;lwg-issues-implemented-this-month&quot;&gt;LWG issues implemented this month&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;I didn’t actually commit any LWG issue fixes this month. I worked with others on several bug fixes that landed, but not under my name.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-features-implemented-this-month-certainly-incomplete&quot;&gt;LLVM features implemented this month (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Add noexcept to &lt;code class=&quot;highlighter-rouge&quot;&gt;operator[]&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Mark &lt;code class=&quot;highlighter-rouge&quot;&gt;vector::operator[]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;front&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;back&lt;/code&gt; as noexcept&lt;/li&gt;
  &lt;li&gt;Mark &lt;code class=&quot;highlighter-rouge&quot;&gt;front()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;back()&lt;/code&gt; as noexcept for &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Make &lt;code class=&quot;highlighter-rouge&quot;&gt;to_chars&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;from_chars&lt;/code&gt; work back to C++11. This lets us use them in &lt;code class=&quot;highlighter-rouge&quot;&gt;to_string&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-this-month-probably-incomplete&quot;&gt;LLVM bugs resolved this month (probably incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/35967&quot;&gt;Bug 35967&lt;/a&gt; &amp;lt;regex&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;syntax_option_type&lt;/code&gt; is not a proper bitmask&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;No bug #&lt;/em&gt; Fix a minor bug with &lt;code class=&quot;highlighter-rouge&quot;&gt;std::next&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;prev&lt;/code&gt; not handling negative numbers.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;No bug #&lt;/em&gt; Cleanup of requirements for &lt;code class=&quot;highlighter-rouge&quot;&gt;optional&lt;/code&gt; - we no longer allow &lt;code class=&quot;highlighter-rouge&quot;&gt;optional&amp;lt;const in_place_t&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/41130&quot;&gt;Bug 41130&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;operator/&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::chrono::duration&lt;/code&gt; and custom type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, there was a series of general cleanups in the libc++ tests to improve portability and readability. Eric and I (mostly Eric) revamped the debug-mode support, and there will be more activity there in the future. Also, we’re moving towards using more of the &lt;code class=&quot;highlighter-rouge&quot;&gt;ASSERT_XXXX&lt;/code&gt; macros for readability, and I revamped about 30 of the tests to use them. Only several thousand to go!&lt;/p&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;The “winter” WG21 meeting was held in Kona, HI on February 18-24. This was the last meeting for new features for C++20, and as such, it was both contentious and very busy.&lt;/p&gt;

&lt;p&gt;Between now and the next meeting (July), LWG will be working on reviewing papers and issues to be adopted in July. We have had three teleconferences since Kona, and a fourth is scheduled for mid-April.&lt;/p&gt;

&lt;p&gt;I am working on more “cleanup” papers similar to &lt;a href=&quot;https://wg21.link/P1458&quot;&gt;P1458 - Mandating the Standard Library: Clause 16 - Language support library&lt;/a&gt;, and my &lt;a href=&quot;https://wg21.link/P0805&quot;&gt;P0805 - Comparing Containers&lt;/a&gt; needs an update.&lt;/p&gt;

&lt;p&gt;The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review.&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;It’s time for another Boost release (1.70), and I am acting as the release manager again. The release calendar is available (as always) on &lt;a href=&quot;https://www.boost.org/development&quot;&gt;the Boost website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The cut-off for contributions for the release is 3-April, with a release candidate to follow close behind, and the actual release to happen on the 10th.&lt;/p&gt;

&lt;p&gt;Once the release is over, I’ll be putting some serious time into Boost.Algorithm; there are a bunch of C++17/20 algorithms that can be added to the library (among other things).&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;I had submitted talk proposals to three conferences, and all three were accepted.&lt;/p&gt;

&lt;p&gt;I will be speaking at:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/devmtg/2019-04&quot;&gt;LLVM European Developer’s Conference&lt;/a&gt;, April 8-9 in Brussels&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://conference.accu.org&quot;&gt;ACCU&lt;/a&gt;, April 10-13 in Bristol&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cppnow.org&quot;&gt;CppNow&lt;/a&gt;, May 5-10 in Aspen, CO&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences This month, I spent far more time reviewing other people’s code and preparing talks for conferences than the previous few months. The Boost release process consumed a fair chunk of time as well. Libc++ The big news is: we released LLVM 8 this month! (March 20th). You can get the sources and pre-built binaries from the LLVM download page, or wait for your system vendor to provide you with an update. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. LWG papers implemented this month. P0811 std::midpoint for integral and pointer types. This turned out to be quite involved, and spawned a clang bug report. On the plus side, now I have a topic for a talk for CppCon this fall. Still to do, std::midpoint for floating point types. This is done, but it needs better tests. LWG issues implemented this month I didn’t actually commit any LWG issue fixes this month. I worked with others on several bug fixes that landed, but not under my name. LLVM features implemented this month (certainly incomplete) Add noexcept to operator[] for array and deque Mark vector::operator[] and front/back as noexcept Mark front() and back() as noexcept for array/deque/string/string_view Make to_chars/from_chars work back to C++11. This lets us use them in to_string. LLVM bugs resolved this month (probably incomplete) Bug 35967 &amp;lt;regex&amp;gt; syntax_option_type is not a proper bitmask No bug # Fix a minor bug with std::next and prev not handling negative numbers. No bug # Cleanup of requirements for optional - we no longer allow optional&amp;lt;const in_place_t&amp;gt; Bug 41130 operator/ of std::chrono::duration and custom type. Also, there was a series of general cleanups in the libc++ tests to improve portability and readability. Eric and I (mostly Eric) revamped the debug-mode support, and there will be more activity there in the future. Also, we’re moving towards using more of the ASSERT_XXXX macros for readability, and I revamped about 30 of the tests to use them. Only several thousand to go! The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 The “winter” WG21 meeting was held in Kona, HI on February 18-24. This was the last meeting for new features for C++20, and as such, it was both contentious and very busy. Between now and the next meeting (July), LWG will be working on reviewing papers and issues to be adopted in July. We have had three teleconferences since Kona, and a fourth is scheduled for mid-April. I am working on more “cleanup” papers similar to P1458 - Mandating the Standard Library: Clause 16 - Language support library, and my P0805 - Comparing Containers needs an update. The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review. Boost It’s time for another Boost release (1.70), and I am acting as the release manager again. The release calendar is available (as always) on the Boost website. The cut-off for contributions for the release is 3-April, with a release candidate to follow close behind, and the actual release to happen on the 10th. Once the release is over, I’ll be putting some serious time into Boost.Algorithm; there are a bunch of C++17/20 algorithms that can be added to the library (among other things). Conferences I had submitted talk proposals to three conferences, and all three were accepted. I will be speaking at: LLVM European Developer’s Conference, April 8-9 in Brussels ACCU, April 10-13 in Bristol CppNow, May 5-10 in Aspen, CO</summary></entry><entry><title type="html">Certify X509 Validation</title><link href="http://cppalliance.org/company,/damian/2019/03/16/Certify-X509-validation.html" rel="alternate" type="text/html" title="Certify X509 Validation" /><published>2019-03-16T00:00:00+00:00</published><updated>2019-03-16T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/03/16/Certify-X509-validation</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/03/16/Certify-X509-validation.html">&lt;h1 id=&quot;certify---x509-certificate-validation&quot;&gt;Certify - X509 certificate validation&lt;/h1&gt;
&lt;p&gt;I always knew that validating a certificate chain presented by a peer is not an
easy procedure, but my recent work in Certify to port over the procedure from
Chromium has only proven that I underestimated the complexity of it. Certificate
revocation seems to be a particularly hard issue, with 2 main categories of
solutions - offline and online validation.&lt;/p&gt;

&lt;h2 id=&quot;online-validation---ocsp&quot;&gt;Online validation - OCSP&lt;/h2&gt;
&lt;p&gt;OCSP is a protocol designed to allow checking the revocation status of a
certificate by sending a request over a subset of HTTP/1.1. At first glance, it
seems it solves the status checking problem on its own. However, OCSP has
problems, inherent to online checking.&lt;/p&gt;

&lt;p&gt;First of all, the validation server might not be currently available - so a lack
of response is most definitely not a state in which a chain can be trusted.
Secondly, the check may be slow, after all, it requires connecting to a separate
service. Additionally, the native Windows API for certificate verification does
the status check synchronously, which means potentially blocking a user’s thread
that typically services asynchronous operations. There is a feature that
alleviates most of these issues, at least from the point of view of a TLS
client, OCSP stapling. Sadly, it’s not very widespread and actually few large
services support it, due to the fact that it increases bandwidth requirements.
Certify will, at some point support both OCSP status checks on the client side
and support for OCSP stapling. The problem here is that OCSP requires a fairly
functional HTTP client and ASN.1 parsing. A lot of this functionality is already
present in OpenSSL, however, integrating it with ASIO and Beast may be tricky.&lt;/p&gt;

&lt;h2 id=&quot;offline-validation---crls-and-google-crlsets&quot;&gt;Offline validation - CRLs and Google CRLSets&lt;/h2&gt;
&lt;p&gt;The traditional method of checking the status of a certificate involves looking
up revocation lists installed in the OS’s store, or downloaded by the
application from the CA. Unfortunately CRLs have issues - an example would be an
incident from a few years ago when CloudFlare performed a mass revocation which
blew up the size of the CRLs by a few orders of magnitude, resulting in a
requirement to download multiple megabytes of data, turning CAs into a major
performance bottleneck. Google came up with a different mechanism, called
CRLSets, which involves a periodic download of a revocation list which is
created by Google’s crawler querying certificate status over OCSP. This
verification method is fairly attractive for applications that run on systems
that already have Google products, since this database is shared, which is why
I’ve chosen to provide an opt-in implementation in Certify. For now, updating
the database will be out of scope, because that requires a few utilties that are
missing from Boost at this time (XML, JSON and an HTTP Client).&lt;/p&gt;

&lt;p&gt;Don’t forget to star the repository: https://github.com/djarek/certify!&lt;/p&gt;</content><author><name></name></author><summary type="html">Certify - X509 certificate validation I always knew that validating a certificate chain presented by a peer is not an easy procedure, but my recent work in Certify to port over the procedure from Chromium has only proven that I underestimated the complexity of it. Certificate revocation seems to be a particularly hard issue, with 2 main categories of solutions - offline and online validation. Online validation - OCSP OCSP is a protocol designed to allow checking the revocation status of a certificate by sending a request over a subset of HTTP/1.1. At first glance, it seems it solves the status checking problem on its own. However, OCSP has problems, inherent to online checking. First of all, the validation server might not be currently available - so a lack of response is most definitely not a state in which a chain can be trusted. Secondly, the check may be slow, after all, it requires connecting to a separate service. Additionally, the native Windows API for certificate verification does the status check synchronously, which means potentially blocking a user’s thread that typically services asynchronous operations. There is a feature that alleviates most of these issues, at least from the point of view of a TLS client, OCSP stapling. Sadly, it’s not very widespread and actually few large services support it, due to the fact that it increases bandwidth requirements. Certify will, at some point support both OCSP status checks on the client side and support for OCSP stapling. The problem here is that OCSP requires a fairly functional HTTP client and ASN.1 parsing. A lot of this functionality is already present in OpenSSL, however, integrating it with ASIO and Beast may be tricky. Offline validation - CRLs and Google CRLSets The traditional method of checking the status of a certificate involves looking up revocation lists installed in the OS’s store, or downloaded by the application from the CA. Unfortunately CRLs have issues - an example would be an incident from a few years ago when CloudFlare performed a mass revocation which blew up the size of the CRLs by a few orders of magnitude, resulting in a requirement to download multiple megabytes of data, turning CAs into a major performance bottleneck. Google came up with a different mechanism, called CRLSets, which involves a periodic download of a revocation list which is created by Google’s crawler querying certificate status over OCSP. This verification method is fairly attractive for applications that run on systems that already have Google products, since this database is shared, which is why I’ve chosen to provide an opt-in implementation in Certify. For now, updating the database will be out of scope, because that requires a few utilties that are missing from Boost at this time (XML, JSON and an HTTP Client). Don’t forget to star the repository: https://github.com/djarek/certify!</summary></entry><entry><title type="html">Gold sponsor of C++Now 2019</title><link href="http://cppalliance.org/company/2019/03/06/Gold-sponsor-of-C++-now.html" rel="alternate" type="text/html" title="Gold sponsor of C++Now 2019" /><published>2019-03-06T00:00:00+00:00</published><updated>2019-03-06T00:00:00+00:00</updated><id>http://cppalliance.org/company/2019/03/06/Gold-sponsor-of-C++-now</id><content type="html" xml:base="http://cppalliance.org/company/2019/03/06/Gold-sponsor-of-C++-now.html">&lt;p&gt;The Alliance is a Gold sponsor for
&lt;a href=&quot;http://cppnow.org/about/corporate_sponsors/&quot;&gt;C++Now 2019&lt;/a&gt;. This
conference is a gathering of C++ experts and enthusiasts from around
the world in beautiful Aspen, Colorado from May 5, 2019 - May 10, 2019.&lt;/p&gt;</content><author><name></name></author><summary type="html">The Alliance is a Gold sponsor for C++Now 2019. This conference is a gathering of C++ experts and enthusiasts from around the world in beautiful Aspen, Colorado from May 5, 2019 - May 10, 2019.</summary></entry><entry><title type="html">Marshall’s March Update</title><link href="http://cppalliance.org/marshall/2019/03/04/MarshallsMarchUpdate.html" rel="alternate" type="text/html" title="Marshall's March Update" /><published>2019-03-04T00:00:00+00:00</published><updated>2019-03-04T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/03/04/MarshallsMarchUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/03/04/MarshallsMarchUpdate.html">&lt;p&gt;Monthly update (or, what Marshall did in January and February)&lt;/p&gt;

&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The LLVM “branch for release” occurred in January, and there was a bit of a rush to get things into the LLVM 8 release. Now that is over, and we’re just watching the test results, seeing if anyone finds any problems with the release. I don’t anticipate any, but you never know.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;p&gt;After the branch, I started working on new features for the LLVM 9 release (for this summer). More calendaring stuff, new C++20 features, and some C++17 features that haven’t been done yet.&lt;/p&gt;

&lt;h3 id=&quot;lwg-papers-implemented-in-janfeb&quot;&gt;LWG papers implemented in Jan/Feb&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;P0355: Extending &lt;chrono&gt; to Calendars and Time Zones. You may remember this from last month's update; this is a huge paper, and I am landing it in stages.&lt;/chrono&gt;&lt;/li&gt;
  &lt;li&gt;P1024: tuple-like interface to span&lt;/li&gt;
  &lt;li&gt;P1227: Signed ssize() functions&lt;/li&gt;
  &lt;li&gt;P1357: Traits for [Un]bounded Arrays&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lwg-issues-implemented-in-janfeb-certainly-incomplete&quot;&gt;LWG issues implemented in Jan/Feb (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LWG3101: span’s Container constructors need another constraint&lt;/li&gt;
  &lt;li&gt;LWG3144: span does not have a const_pointer typedef&lt;/li&gt;
  &lt;li&gt;Enabled a &lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy&lt;/code&gt; optimization for const vectors that was surprisingly missing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-in-janfeb-probably-incomplete&quot;&gt;LLVM bugs resolved in Jan/Feb (probably incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR28412&quot;&gt;Bug 28412&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt; incorrectly requires CopyConstructible, Destructible and other concepts&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR39183&quot;&gt;Bug 39183&lt;/a&gt; tuple comparison operators return true for tuples of different sizes&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR24411&quot;&gt;Bug 24411&lt;/a&gt; libFuzzer outputs that crash libc++’s regex engine&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR34330&quot;&gt;Bug 34330&lt;/a&gt; error: use of undeclared identifier ‘isascii’ while compiling strstream.cpp&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR38606&quot;&gt;Bug 38606&lt;/a&gt; no_sanitize(“unsigned-integer-overflow”) annotation for decremented size_type in &lt;code class=&quot;highlighter-rouge&quot;&gt;__hash_table&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR40533&quot;&gt;Bug 40533&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::minmax_element&lt;/code&gt; is 3 times slower than hand written loop&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR18584&quot;&gt;Bug 18584&lt;/a&gt; SD-6 Feature Test Recommendations&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR40566&quot;&gt;Bug 40566&lt;/a&gt; Libc++ is not Implicit Integer Truncation Sanitizer clean&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR21715&quot;&gt;Bug 21715&lt;/a&gt; 128-bit integers printing not supported in stl implementation&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR38844&quot;&gt;Bug 38844&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;__cpp_lib_make_unique&lt;/code&gt; not defined in &amp;lt;memory&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR40495&quot;&gt;Bug 40495&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;is_invokable_v&amp;lt;void&amp;gt;&lt;/code&gt; does not compile&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR40270&quot;&gt;Bug 40270&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::basic_stringstream&lt;/code&gt; is not working with &lt;code class=&quot;highlighter-rouge&quot;&gt;std::byte&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR39871&quot;&gt;Bug 39871&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple_size&lt;/code&gt; should be a struct&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR38052&quot;&gt;Bug 38052&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::fstream&lt;/code&gt; still good after closing and updating content&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, there was a series of general cleanups in the libc++ tests to improve portability.&lt;/p&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;The “winter” WG21 meeting was held in Kona, HI on February 18-24. This was the last meeting for new features for C++20, and as such, it was both contentious and very busy.&lt;/p&gt;

&lt;p&gt;The Modules TS and the Coroutines TS were both adopted for C++20, along with a slew of language features.&lt;/p&gt;

&lt;p&gt;Here are some trip reports:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbsutter.com/2019/02/23/trip-report-winter-iso-c-standards-meeting-kona/&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/au0c4x/201902_kona_iso_c_committee_trip_report_c20/&quot;&gt;Bryce Adelstein Lelbach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hatcat.com/?p=69&quot;&gt;Guy Davidson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My part in this was (as always) to chair the Library Working Group (LWG), the group responsible for the description of the library features in the standard (~1000 pages).
We adopted several new features for C++20:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P0339R6 polymorphic_allocator&amp;lt;&amp;gt; as a vocabulary type&lt;/li&gt;
  &lt;li&gt;P0340R3 Making std::underlying_type SFINAE-friendly&lt;/li&gt;
  &lt;li&gt;P0738R2 I Stream, You Stream, We All Stream for istream_iterator&lt;/li&gt;
  &lt;li&gt;P0811R3 Well-behaved interpolation for numbers and pointers&lt;/li&gt;
  &lt;li&gt;P0920R2 Precalculated hash values in lookup&lt;/li&gt;
  &lt;li&gt;P1001R2 Target Vectorization Policies from Parallelism V2 TS to C++20&lt;/li&gt;
  &lt;li&gt;P1024R3 Usability Enhancements for std::span&lt;/li&gt;
  &lt;li&gt;P1164R1 Make create_directory() Intuitive&lt;/li&gt;
  &lt;li&gt;P1227R2 Signed ssize() functions, unsigned size() functions&lt;/li&gt;
  &lt;li&gt;P1252R2 Ranges Design Cleanup&lt;/li&gt;
  &lt;li&gt;P1357R1 Traits for [Un]bounded Arrays&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I wrote five substantive papers for the Kona meeting, all were adopted. Five of them were very similar, all about improving the wording in the standard, rather than proposing new features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1458&quot;&gt;P1458&lt;/a&gt; Mandating the Standard Library: Clause 16 - Language support library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1459&quot;&gt;P1459&lt;/a&gt; Mandating the Standard Library: Clause 18 - Diagnostics library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1462&quot;&gt;P1462&lt;/a&gt; Mandating the Standard Library: Clause 20 - Strings library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1463&quot;&gt;P1463&lt;/a&gt; Mandating the Standard Library: Clause 21 - Containers library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1464&quot;&gt;P1464&lt;/a&gt; Mandating the Standard Library: Clause 22 - Iterators library&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I was also the nominal author of &lt;a href=&quot;https://wg21.link/P1457&quot;&gt;P1457&lt;/a&gt; “C++ Standard Library Issues to be moved in Kona”, but that was just a list of issues whose resolutions we adopted.&lt;/p&gt;

&lt;p&gt;Between now and the next meeting (July), LWG will be working on reviewing papers and issues to be adopted in July. I’m planning regular teleconferences (in fact, we had the first one on 1-March).&lt;/p&gt;

&lt;p&gt;The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review.&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;It’s been a quiet couple of months for Boost, since we’re between releases, and I have been busy with libc++ and WG21 activities. There have been a few bugs to chase down, and the dealing with change requests for the libraries whose maintainers have “moved on” takes some time.&lt;/p&gt;

&lt;p&gt;However, it’s time for another Boost release (1.70), and I will be acting as the release manager again. The release calendar is available (as always) on &lt;a href=&quot;https://www.boost.org/development&quot;&gt;the Boost website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The beta release is schedule for March 13th, and the final release for 10-April.&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;I had submitted talk proposals to three conferences, and all three were accepted. Hence, I will be speaking at:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/devmtg/2019-04&quot;&gt;LLVM European Developer’s Conference&lt;/a&gt;, April 8-9 in Brussels&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://conference.accu.org&quot;&gt;ACCU&lt;/a&gt;, April 10-13 in Bristol&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cppnow.org&quot;&gt;CppNow&lt;/a&gt;, May 5-10 in Aspen, CO&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Monthly update (or, what Marshall did in January and February) There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences Libc++ The LLVM “branch for release” occurred in January, and there was a bit of a rush to get things into the LLVM 8 release. Now that is over, and we’re just watching the test results, seeing if anyone finds any problems with the release. I don’t anticipate any, but you never know. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. After the branch, I started working on new features for the LLVM 9 release (for this summer). More calendaring stuff, new C++20 features, and some C++17 features that haven’t been done yet. LWG papers implemented in Jan/Feb P0355: Extending to Calendars and Time Zones. You may remember this from last month's update; this is a huge paper, and I am landing it in stages. P1024: tuple-like interface to span P1227: Signed ssize() functions P1357: Traits for [Un]bounded Arrays LWG issues implemented in Jan/Feb (certainly incomplete) LWG3101: span’s Container constructors need another constraint LWG3144: span does not have a const_pointer typedef Enabled a memcpy optimization for const vectors that was surprisingly missing LLVM bugs resolved in Jan/Feb (probably incomplete) Bug 28412 std::vector incorrectly requires CopyConstructible, Destructible and other concepts Bug 39183 tuple comparison operators return true for tuples of different sizes Bug 24411 libFuzzer outputs that crash libc++’s regex engine Bug 34330 error: use of undeclared identifier ‘isascii’ while compiling strstream.cpp Bug 38606 no_sanitize(“unsigned-integer-overflow”) annotation for decremented size_type in __hash_table Bug 40533 std::minmax_element is 3 times slower than hand written loop Bug 18584 SD-6 Feature Test Recommendations Bug 40566 Libc++ is not Implicit Integer Truncation Sanitizer clean Bug 21715 128-bit integers printing not supported in stl implementation Bug 38844 __cpp_lib_make_unique not defined in &amp;lt;memory&amp;gt; Bug 40495 is_invokable_v&amp;lt;void&amp;gt; does not compile Bug 40270 std::basic_stringstream is not working with std::byte Bug 39871 std::tuple_size should be a struct Bug 38052 std::fstream still good after closing and updating content Also, there was a series of general cleanups in the libc++ tests to improve portability. The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 The “winter” WG21 meeting was held in Kona, HI on February 18-24. This was the last meeting for new features for C++20, and as such, it was both contentious and very busy. The Modules TS and the Coroutines TS were both adopted for C++20, along with a slew of language features. Here are some trip reports: Herb Sutter Bryce Adelstein Lelbach Guy Davidson My part in this was (as always) to chair the Library Working Group (LWG), the group responsible for the description of the library features in the standard (~1000 pages). We adopted several new features for C++20: P0339R6 polymorphic_allocator&amp;lt;&amp;gt; as a vocabulary type P0340R3 Making std::underlying_type SFINAE-friendly P0738R2 I Stream, You Stream, We All Stream for istream_iterator P0811R3 Well-behaved interpolation for numbers and pointers P0920R2 Precalculated hash values in lookup P1001R2 Target Vectorization Policies from Parallelism V2 TS to C++20 P1024R3 Usability Enhancements for std::span P1164R1 Make create_directory() Intuitive P1227R2 Signed ssize() functions, unsigned size() functions P1252R2 Ranges Design Cleanup P1357R1 Traits for [Un]bounded Arrays I wrote five substantive papers for the Kona meeting, all were adopted. Five of them were very similar, all about improving the wording in the standard, rather than proposing new features. P1458 Mandating the Standard Library: Clause 16 - Language support library P1459 Mandating the Standard Library: Clause 18 - Diagnostics library P1462 Mandating the Standard Library: Clause 20 - Strings library P1463 Mandating the Standard Library: Clause 21 - Containers library P1464 Mandating the Standard Library: Clause 22 - Iterators library I was also the nominal author of P1457 “C++ Standard Library Issues to be moved in Kona”, but that was just a list of issues whose resolutions we adopted. Between now and the next meeting (July), LWG will be working on reviewing papers and issues to be adopted in July. I’m planning regular teleconferences (in fact, we had the first one on 1-March). The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review. Boost It’s been a quiet couple of months for Boost, since we’re between releases, and I have been busy with libc++ and WG21 activities. There have been a few bugs to chase down, and the dealing with change requests for the libraries whose maintainers have “moved on” takes some time. However, it’s time for another Boost release (1.70), and I will be acting as the release manager again. The release calendar is available (as always) on the Boost website. The beta release is schedule for March 13th, and the final release for 10-April. Conferences I had submitted talk proposals to three conferences, and all three were accepted. Hence, I will be speaking at: LLVM European Developer’s Conference, April 8-9 in Brussels ACCU, April 10-13 in Bristol CppNow, May 5-10 in Aspen, CO</summary></entry><entry><title type="html">Adler &amp;amp; Colvin engaged</title><link href="http://cppalliance.org/company/2019/03/01/Adler-Colvin-engaged.html" rel="alternate" type="text/html" title="Adler &amp; Colvin engaged" /><published>2019-03-01T00:00:00+00:00</published><updated>2019-03-01T00:00:00+00:00</updated><id>http://cppalliance.org/company/2019/03/01/Adler-Colvin-engaged</id><content type="html" xml:base="http://cppalliance.org/company/2019/03/01/Adler-Colvin-engaged.html">&lt;p&gt;The Alliance engages
&lt;a href=&quot;https://www.adlercolvin.com/&quot;&gt;Adler &amp;amp; Colvin&lt;/a&gt;
to complete IRS Form 1023, Application for Recognition of Exemption Under Section 501(c)(3) of the Internal Revenue Code. Completing this form can be a daunting task because of the legal and tax technicalities you’ll need to understand. Adler &amp;amp; Colvin is a group of seasoned attorneys based in San Francisco, deeply committed to serving the legal needs of the nonprofit sector.  The firm brings an unrivaled depth of expertise and passion to its representation of tax-exempt organizations and individual philanthropists.&lt;/p&gt;</content><author><name></name></author><summary type="html">The Alliance engages Adler &amp;amp; Colvin to complete IRS Form 1023, Application for Recognition of Exemption Under Section 501(c)(3) of the Internal Revenue Code. Completing this form can be a daunting task because of the legal and tax technicalities you’ll need to understand. Adler &amp;amp; Colvin is a group of seasoned attorneys based in San Francisco, deeply committed to serving the legal needs of the nonprofit sector. The firm brings an unrivaled depth of expertise and passion to its representation of tax-exempt organizations and individual philanthropists.</summary></entry><entry><title type="html">Marshall’s January Update</title><link href="http://cppalliance.org/marshall/2019/01/14/MarshallsJanuaryUpdate.html" rel="alternate" type="text/html" title="Marshall's January Update" /><published>2019-01-14T00:00:00+00:00</published><updated>2019-01-14T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/01/14/MarshallsJanuaryUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/01/14/MarshallsJanuaryUpdate.html">&lt;p&gt;Monthly update (or, what Marshall did in December)&lt;/p&gt;

&lt;p&gt;There are three main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Libc++&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;Boost:
December was a big month for boost, and much of the first part of the month was taken up with the release process. I was the release manager for the 1.69.0 release, which went live on 12-December. The final release process was fairly straighforward, with only one release candidate being made/tested - as opposed to the beta, which took &lt;em&gt;three&lt;/em&gt;. In any case, we had a successful release, and the I (and other boost developers) are now happily working on features/bug fixes for the 1.70 release - which will occur in March.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Libc++:
After the WG21 meeting in November, there was a bunch of new functionality to be added to libc++. The list of new features (and their status) can be seen &lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;on the libc++ website&lt;/a&gt;.  My major contributions of new features in December were &lt;a href=&quot;https://wg21.link/P1209R0&quot;&gt;Consistent Container Erasure&lt;/a&gt;, &lt;a href=&quot;https://wg21.link/P0482&quot;&gt;char8_t: A type for UTF-8 characters and strings&lt;/a&gt;, and &lt;a href=&quot;https://wg21.link/P1085R2&quot;&gt;Should Span be Regular?&lt;/a&gt;, and a big chunk of [Extending &lt;chrono&gt; to Calendars and Time Zones](https://wg21.link/P0355R7).&lt;/chrono&gt;&lt;/p&gt;

&lt;p&gt;This is all pointing towards the January 16th “branch for release”, and for the scheduled March release of LLVM 8.0.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never ending task; there are new contributions ever day.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;WG21&lt;/p&gt;

&lt;p&gt;Being between meetings (November -&amp;gt; February) there was not any special WG21 work to be done in December. There’s an ongoing stream of bug reports, discussion, paper reviews that get done between meetings, and there is a series of papers that I need to finish for the pre-Meeting mailing deadline on 21-January. I have 1 1/2 done, and need to do 3-4 more.&lt;/p&gt;</content><author><name></name></author><summary type="html">Monthly update (or, what Marshall did in December) There are three main areas where I spend my time. Boost Libc++ WG21, where I am the chair of the Library Working Group (LWG) Boost: December was a big month for boost, and much of the first part of the month was taken up with the release process. I was the release manager for the 1.69.0 release, which went live on 12-December. The final release process was fairly straighforward, with only one release candidate being made/tested - as opposed to the beta, which took three. In any case, we had a successful release, and the I (and other boost developers) are now happily working on features/bug fixes for the 1.70 release - which will occur in March. Libc++: After the WG21 meeting in November, there was a bunch of new functionality to be added to libc++. The list of new features (and their status) can be seen on the libc++ website. My major contributions of new features in December were Consistent Container Erasure, char8_t: A type for UTF-8 characters and strings, and Should Span be Regular?, and a big chunk of [Extending to Calendars and Time Zones](https://wg21.link/P0355R7). This is all pointing towards the January 16th “branch for release”, and for the scheduled March release of LLVM 8.0. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never ending task; there are new contributions ever day. WG21 Being between meetings (November -&amp;gt; February) there was not any special WG21 work to be done in December. There’s an ongoing stream of bug reports, discussion, paper reviews that get done between meetings, and there is a series of papers that I need to finish for the pre-Meeting mailing deadline on 21-January. I have 1 1/2 done, and need to do 3-4 more.</summary></entry><entry><title type="html">Wg21 San Diego Trip Report</title><link href="http://cppalliance.org/standards,/marshall/2018/11/13/WG21-San-Diego-Trip-Report.html" rel="alternate" type="text/html" title="Wg21 San Diego Trip Report" /><published>2018-11-13T00:00:00+00:00</published><updated>2018-11-13T00:00:00+00:00</updated><id>http://cppalliance.org/standards,/marshall/2018/11/13/WG21-San-Diego-Trip-Report</id><content type="html" xml:base="http://cppalliance.org/standards,/marshall/2018/11/13/WG21-San-Diego-Trip-Report.html">&lt;h1 id=&quot;wg21-san-diego-meeting&quot;&gt;WG21 San Diego Meeting&lt;/h1&gt;

&lt;p&gt;Last week was the fall 2018 WG21 standard committee meeting. It was held
in San Diego, which is my hometown. The fact that I helped organize it
(while I was working at Qualcomm) had absolutely no affect on the location,
I assure you. ;-)&lt;/p&gt;

&lt;p&gt;This was the largest WG21 meeting ever, with 180 attendees. The last meeting
(in Rapperswil, Switzerland) had about 150 attendees, and &lt;em&gt;that&lt;/em&gt; was the
largest one until now. There were more than 270 papers in the pre-meeting
mailing; meaning that people were spending weeks reading papers to prepare
for the meeting. Herb Sutter (the convener) has been telling everyone that
new papers received after the San Diego meeting were out of scope for C++20,
and apparently people took him at his word.&lt;/p&gt;

&lt;p&gt;This was my first meeting representing the C++ Alliance (though hardly my
first overall). The Alliance was well represented, with Rene, Glen, Vinnie,
Jon and myself attending. For information about how WG21 is structured,
please see &lt;a href=&quot;https://isocpp.org/std&quot;&gt;isocpp.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I spent all of my time in LWG, since that’s the group that I chair, and the
one that has the most influence over libc++, the library that I work on.&lt;/p&gt;

&lt;p&gt;The big news from a library POV was that we voted to merge an updated paper
based on the Ranges TS into the draft standard; which means that (barring
catastrophe) that it will be part of C++20. This was a huge paper, weighing
in at 220+ pages. We spent several days in LWG reviewing this (and a bunch
of time at previous meetings as well).&lt;/p&gt;

&lt;p&gt;We also moved a bunch (around 25) of smaller papers; too many to list here.&lt;/p&gt;

&lt;p&gt;Detailed trip reports can be found around the web:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/&quot;&gt;Herb Sutter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/9vwvbz/2018_san_diego_iso_c_committee_trip_report_ranges/&quot;&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next WG21 meeting is in Kona, HI February 18-23rd.&lt;/p&gt;</content><author><name></name></author><summary type="html">WG21 San Diego Meeting Last week was the fall 2018 WG21 standard committee meeting. It was held in San Diego, which is my hometown. The fact that I helped organize it (while I was working at Qualcomm) had absolutely no affect on the location, I assure you. ;-) This was the largest WG21 meeting ever, with 180 attendees. The last meeting (in Rapperswil, Switzerland) had about 150 attendees, and that was the largest one until now. There were more than 270 papers in the pre-meeting mailing; meaning that people were spending weeks reading papers to prepare for the meeting. Herb Sutter (the convener) has been telling everyone that new papers received after the San Diego meeting were out of scope for C++20, and apparently people took him at his word. This was my first meeting representing the C++ Alliance (though hardly my first overall). The Alliance was well represented, with Rene, Glen, Vinnie, Jon and myself attending. For information about how WG21 is structured, please see isocpp.org. I spent all of my time in LWG, since that’s the group that I chair, and the one that has the most influence over libc++, the library that I work on. The big news from a library POV was that we voted to merge an updated paper based on the Ranges TS into the draft standard; which means that (barring catastrophe) that it will be part of C++20. This was a huge paper, weighing in at 220+ pages. We spent several days in LWG reviewing this (and a bunch of time at previous meetings as well). We also moved a bunch (around 25) of smaller papers; too many to list here. Detailed trip reports can be found around the web: Herb Sutter Reddit The next WG21 meeting is in Kona, HI February 18-23rd.</summary></entry><entry><title type="html">Initial Work On Certify Complete</title><link href="http://cppalliance.org/company,/damian/2018/10/24/Initial-work-on-Certify-complete.html" rel="alternate" type="text/html" title="Initial Work On Certify Complete" /><published>2018-10-24T00:00:00+00:00</published><updated>2018-10-24T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2018/10/24/Initial-work-on-Certify-complete</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2018/10/24/Initial-work-on-Certify-complete.html">&lt;h1 id=&quot;initial-work-on-certify-complete&quot;&gt;Initial work on &lt;code class=&quot;highlighter-rouge&quot;&gt;Certify&lt;/code&gt; complete&lt;/h1&gt;
&lt;p&gt;It’s been mentioned in my initial blog post that I’d be working on a TLS
certificate store abstraction library, with the intent of submitting it for
formal review for Boost, at some point in the (hopefully near) future.
The initial setup phase (things that every Software Engineer hates) is more
or less complete. CI setup was a bit tricky - getting OpenSSL to run with
the boost build system on both Windows and Linux (and in the future MacOS)
has provided a lot of “fun” thanks to the inherent weirdness of OpenSSL.&lt;/p&gt;

&lt;p&gt;The test harness currently consists of two test runners that loads certificates
from a database (big name for a folder structure stored in git) that has the
certificate chains divided into two groups. Chains that will fail due to various
reasons (e.g. self-signed certificates, wrong domain name) and ones that will pass
(when using a valid certificate store). I’m still working on checking whether
the failure was for the expected reason. All the verification is done offline
(i.e. no communication with external servers is performed, only chain verification).&lt;/p&gt;

&lt;p&gt;At this point it looks like I should consider, whether the current design of
the verification code is a good approach. Using the verification callback
from OpenSSL and asio::ssl is quite an easy way of integrating the platform-specific
certificate store API it causes issues with error propagation (transporting a platform-specific
error through OpenSSL) and may be fairly slow, because it requires certificates to be
reencdoded into the DER format so that they can be fed into the platform-specific API.
An alternative to this approach would be load the entire root certificate store, along with CRLs and
OCSP configuration into an OpenSSL context. This is potentially a little bit harder to get right but
may offer better performance (no reencoding required when veryfing certificate chains) and eliminates
the issues related to error handling. Further investigation, as to which approach is better, is required.&lt;/p&gt;

&lt;p&gt;Don’t forget to star the repository: https://github.com/djarek/certify!&lt;/p&gt;</content><author><name></name></author><summary type="html">Initial work on Certify complete It’s been mentioned in my initial blog post that I’d be working on a TLS certificate store abstraction library, with the intent of submitting it for formal review for Boost, at some point in the (hopefully near) future. The initial setup phase (things that every Software Engineer hates) is more or less complete. CI setup was a bit tricky - getting OpenSSL to run with the boost build system on both Windows and Linux (and in the future MacOS) has provided a lot of “fun” thanks to the inherent weirdness of OpenSSL. The test harness currently consists of two test runners that loads certificates from a database (big name for a folder structure stored in git) that has the certificate chains divided into two groups. Chains that will fail due to various reasons (e.g. self-signed certificates, wrong domain name) and ones that will pass (when using a valid certificate store). I’m still working on checking whether the failure was for the expected reason. All the verification is done offline (i.e. no communication with external servers is performed, only chain verification). At this point it looks like I should consider, whether the current design of the verification code is a good approach. Using the verification callback from OpenSSL and asio::ssl is quite an easy way of integrating the platform-specific certificate store API it causes issues with error propagation (transporting a platform-specific error through OpenSSL) and may be fairly slow, because it requires certificates to be reencdoded into the DER format so that they can be fed into the platform-specific API. An alternative to this approach would be load the entire root certificate store, along with CRLs and OCSP configuration into an OpenSSL context. This is potentially a little bit harder to get right but may offer better performance (no reencoding required when veryfing certificate chains) and eliminates the issues related to error handling. Further investigation, as to which approach is better, is required. Don’t forget to star the repository: https://github.com/djarek/certify!</summary></entry><entry><title type="html">Gold Sponsor Of Cppcon 2018</title><link href="http://cppalliance.org/company/2018/09/23/Gold-sponsor-of-Cppcon-2018.html" rel="alternate" type="text/html" title="Gold Sponsor Of Cppcon 2018" /><published>2018-09-23T00:00:00+00:00</published><updated>2018-09-23T00:00:00+00:00</updated><id>http://cppalliance.org/company/2018/09/23/Gold-sponsor-of-Cppcon-2018</id><content type="html" xml:base="http://cppalliance.org/company/2018/09/23/Gold-sponsor-of-Cppcon-2018.html">&lt;p&gt;
The Alliance is a Gold sponsor for
&lt;a href=&quot;https://cppcon.org/history/2018/&quot;&gt;CppCon 2018&lt;/a&gt;. This
conference is the annual, week-long face-to-face gathering for the
entire C++ community. The conference is organized by the C++ community
for the community. Attendees enjoy inspirational talks and a friendly
atmosphere designed to help individuals learn from each other, meet
interesting people, and generally have a stimulating experience.
&lt;/p&gt;</content><author><name></name></author><summary type="html">The Alliance is a Gold sponsor for CppCon 2018. This conference is the annual, week-long face-to-face gathering for the entire C++ community. The conference is organized by the C++ community for the community. Attendees enjoy inspirational talks and a friendly atmosphere designed to help individuals learn from each other, meet interesting people, and generally have a stimulating experience.</summary></entry></feed>